/*
This class is the class that does all the computations for the simple harmonic motion simulator
 */
package physics;

public class SHM {
    private Double F, m, a, Ue, Ke, E, T; //force, mass, acceleration, potential E, kinetic E, energy, time, period
    private Double k, amp, w, ps; //spring constant, amplitude, accl-pos value, phase shift
    private Double l, g, theta; //length, gravity field strength, angle
    private Double vx, vy, x, y, v; //x velocity, y velocity, x (real life), y (real life) v (real life)
    private final Double maxRad = 7*Math.PI/90, maxDeg = 14.0;
    private boolean isRad;

    /*
    This is the constructor for the SHM.java class
    It gives every variable above a value
     */
    public SHM(){
        F = m = a = k = amp = w = T = ps = Ue = Ke = E = l = 0.0;
        x = v = 0.0;
        g = 9.8;
        isRad = true;
        amp = 1.0;
        k = 1.0;
        m = 1.0;
        ps=0.0;
        l = 1.0;
        theta = Math.PI/12;
        System.out.println(theta);
    }

    /*
    The following two functions are the functions that calculate the x and y values of the SHM simulation
    The value it returns is the value that it represents in real life, and SHMGUI.java then transcribes it to the screen
    In theory, both funcitons would check what kind of SHM is being simulated, and then calculate accordingly
    However, there is no SHM to be simulated in the y direction for the spring, so it does not check. It is never called in SHMGUI.java for springs either
    */

    public Double calcX(double time, int type){
        //offset: 250px to 750px
        Double angle;
        if (isRad)
            angle = theta;
        else
            angle = Math.toRadians(theta);
        if (type == 1) {
            Double inside = w * time + ps;
            double i = inside;
            x = amp * Math.cos(i);
            v = -1 * w * amp * Math.sin(i);
            a = -1 * Math.pow(w, 2.0) * amp * Math.cos(i);
            //xp = 500 + x / amp * 250;
            //System.out.println("t:" + time);
            //System.out.println("x:" + x);
        }
        else if (type == 2){
            double i = Math.cos(w*time)*angle;
            x = Math.sin(i)*l;
            v = w * Math.cos(i);
            a = -1 * Math.pow(w, 2.0) * Math.sin(i);
            //xp = x/l*400+450;
            //System.out.println("t:" + time);
            //System.out.println("o:" + i);
        }
        return x;
    }

    public Double calcY(double time, int type){
        Double angle;
        if (isRad)
            angle = theta;
        else
            angle = Math.toRadians(theta);
        if (type == 2) {
            double i = Math.cos(w * time) * angle;
            y = Math.cos(i)*l;
            //yp = y/l*400+450;
        }
        return y;
    }

    /*
    This function calculates values that are updating in real time, unrelated to the position
    This includes potential energy, kinetic energy, force, and the angular frequency
    There is a possibility the user may enter a 0 for the mass or length, so it checks to see if an exception is thrown resultantly
     */
    public void calcVal(double time, int type){
        Ue = .5*k*Math.pow(x,2);
        Ke = .5*m*Math.pow(v,2);
        F = -1*k*x;
        try{
            if (type == 1)
                w = Math.sqrt(k/m);
            else if (type == 2)
                w = Math.sqrt(g/l);
        }
        catch(ArithmeticException e){
            w=0.0;
        }
    }

    /*
    This function calculates the values that are constant throughout the simulation
    This only includes the period and the total energy
     */
    public void calcConstant(int type){
        //w = Math.sqrt(k.doubleValue()/m.doubleValue());
        E = .5*k*Math.pow(x,2) + .5*m*Math.pow(v,2);
        T = 2*Math.PI/w;
    }

    /*
    Beyond this point is the section that holds the getter and setter methods for each variable
    These are automatically generated by the IDE
    However, most of the setter methods have been modified by myself to be better situated to the simulation
    Instead of simply receiving a double as a parameter, it receives a string and parses it for a double. It then sets the variable associated with it to that value, and returns it again
    If for whatever reason it cannot parse the string, it returns null
    There is one exception which is for theta: instead of simply parsing the double, it will check if the mode is in degrees or radians
     */

    public Double getX() {
        return x;
    }

    public void setX(Double x) {
        this.x = x;
    }

    public Double getV() {
        return v;
    }

    public void setV(Double v) {
        this.v = v;
    }

    public Double getF() {
        return F;
    }

    public Double setF(String s) {
        try {
            F = Double.parseDouble(s);
            return F;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public double getM() {
        return m;
    }

    public Double setM(String s) {
        try {
            m = Math.abs(Double.parseDouble(s));
            return m;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getA() {
        return a;
    }

    public Double setA(String s) {
        try {
            a = Double.parseDouble(s);
            return a;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getUe() {
        return Ue;
    }

    public Double setUE(String s) {
        try {
            Ue = Double.parseDouble(s);
            return Ue;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getKe() {
        return Ke;
    }

    public Double setKE(String s) {
        try {
            Ke = Double.parseDouble(s);
            return Ke;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getE() {
        return E;
    }

    public Double setE(String s) {
        E = Ue + Ke;
        return E;
    }

    public Double getT() {
        return T;
    }

    public Double setT(String s) {
        try {
            T = Double.parseDouble(s);
            return T;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getK() {
        return k;
    }

    public Double setK(String s) {
        try {
            k = Math.abs(Double.parseDouble(s));
            return k;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getAmp() {
        return amp;
    }

    public Double setAmp(String s) {
        try {
            amp = Math.abs(Double.parseDouble(s));
            return amp;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getW() {
        return w;
    }

    public Double setW(String s) {
        try {
            w = Math.abs(Double.parseDouble(s));
            return w;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getPS() {
        return ps;
    }

    public Double setPS(String s) {
        try {
            ps = Double.parseDouble(s);
            return ps;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getL() {
        return l;
    }

    public Double setL(String s) {
        try {
            l = Math.abs(Double.parseDouble(s));
            return l;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getG() {
        return g;
    }

    public Double setG(String s) {
        try {
            g = Math.abs(Double.parseDouble(s));
            return g;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getTheta() {
        return theta;
    }

    public Double setTheta(String s) {
        try {
            Double thetax = Double.parseDouble(s);
            if (isRad) {
                if (Math.abs(thetax) > maxRad)
                    theta = maxRad;
                else
                    theta = thetax;
            }
            else {
                if (Math.abs(thetax) > maxDeg)
                    theta = maxDeg;
                else
                    theta = thetax;
            }
            return theta;
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public Double getVx() {
        return vx;
    }

    public void setVx(Double vx) {
        this.vx = vx;
    }

    public Double getVy() {
        return vy;
    }

    public void setVy(Double vy) {
        this.vy = vy;
    }
    
    public boolean isIsRad() {
        return isRad;
    }

    public void setIsRad(boolean isRad) {
        this.isRad = isRad;
    }
}
